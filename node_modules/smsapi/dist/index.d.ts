type QueryParams = Record<string, unknown>;
interface RequestConfig {
    url: string;
    method: string;
    headers: Record<string, string>;
    body?: Record<string, unknown> | string | FormData;
    params?: QueryParams;
}
interface RequestOptions {
    headers?: Record<string, string>;
    params?: QueryParams;
}
interface ApiResponse<T = unknown> {
    data: T;
    status: number;
    statusText: string;
    headers: Headers;
}
type RequestInterceptor = (config: RequestConfig) => RequestConfig;
type ResponseInterceptor = <T = unknown>(response: ApiResponse<T>) => ApiResponse<T>;
declare class HttpClient {
    private baseUrl;
    private defaultHeaders;
    private requestInterceptors;
    private responseInterceptors;
    constructor(baseUrl: string, defaultHeaders?: Record<string, string>);
    addRequestInterceptor: (interceptor: RequestInterceptor) => void;
    addResponseInterceptor: (interceptor: ResponseInterceptor) => void;
    private buildUrl;
    private runRequestInterceptors;
    private runResponseInterceptors;
    private makeRequest;
    get: <T>(endpoint: string, options?: RequestOptions) => Promise<T>;
    post: <T>(endpoint: string, body?: RequestConfig["body"], options?: RequestOptions) => Promise<T>;
    put: <T>(endpoint: string, body?: RequestConfig["body"], options?: RequestOptions) => Promise<T>;
    patch: <T>(endpoint: string, body: RequestConfig["body"], options?: RequestOptions) => Promise<T>;
    delete: <T>(endpoint: string, options?: RequestOptions) => Promise<T>;
}

declare class BaseModule {
    protected httpClient: HttpClient;
    constructor(httpClient: HttpClient);
}

interface ApiCollection<T> {
    collection: T[];
    size: number;
}

type ContactGender = 'female' | 'male' | 'undefined';

interface Contact {
    id: string;
    firstName: string;
    lastName: string;
    phoneNumber: string;
    email: string;
    gender: ContactGender;
    birthdayDate: Date;
    description: string;
    city: string;
    source: string;
}

interface NewContact {
    firstName?: string;
    lastName?: string;
    email?: string;
    gender?: ContactGender;
    birthdayDate?: Date;
    description?: string;
    city?: string;
    source?: string;
}

interface GetContactsQueryParams extends QueryParams {
    q?: string;
    offset?: number;
    limit?: number;
    orderBy?: 'first_name' | 'last_name' | 'date_updated' | 'date_created';
    phoneNumber?: string | string[];
    email?: string | string[];
    firstName?: string | string[];
    lastName?: string | string[];
    groupId?: string | string[];
    gender?: ContactGender;
    birthdayDate?: Date | Date[];
}

interface CreateGroupDetails {
    description?: string;
    idx?: string;
    contactExpireAfter?: number;
}

interface GroupPermission {
    groupId: string;
    username: string;
    write: boolean;
    read: boolean;
    send: boolean;
}

interface Group {
    id: string;
    name: string;
    description: string;
    contactsCount: number;
    dateCreated: Date;
    dateUpdated: Date;
    createdBy: string;
    idx: string | null;
    permissions: GroupPermission[];
}

interface UpdateGroup extends Partial<CreateGroupDetails> {
    name?: string;
}

declare class Groups extends BaseModule {
    get(): Promise<ApiCollection<Group>>;
    getById(groupId: string): Promise<Group>;
    create(name: string, details?: CreateGroupDetails): Promise<Group>;
    update(groupId: string, updateGroup: UpdateGroup): Promise<Group>;
    remove(groupId: string, deleteContacts?: boolean): Promise<void>;
}

interface UpdateContact extends NewContact {
    phoneNumber?: string;
}

type FieldType = 'text' | 'date' | 'email' | 'phone_number' | 'number';

interface Field {
    id: string;
    name: string;
    type: FieldType;
}

declare class Fields extends BaseModule {
    get(): Promise<ApiCollection<Field>>;
    create(fieldName: string, fieldType?: FieldType): Promise<Field>;
    update(fieldId: string, newName: string): Promise<Field>;
    remove(fieldId: string): Promise<void>;
}

declare class Contacts extends BaseModule {
    fields: Fields;
    groups: Groups;
    constructor(httpClient: HttpClient);
    get(params?: GetContactsQueryParams): Promise<ApiCollection<Contact>>;
    getById(contactId: string): Promise<Contact>;
    create(phoneNumber: string, details?: NewContact): Promise<Contact>;
    update(contactId: string, updateContact: UpdateContact): Promise<Contact>;
    remove(contactId: string): Promise<void>;
    getGroups(contactId: string): Promise<ApiCollection<Group>>;
    getGroupById(contactId: string, groupId: string): Promise<Group>;
    assignContactToGroup(contactId: string, groupId: string): Promise<ApiCollection<Group>>;
    unpinContactFromGroup(contactId: string, groupId: string): Promise<void>;
    private formatContactDetails;
}

interface HlrCheck {
    id: string;
    number: string;
    price: number;
    status: 'OK';
}

interface HlrCheckError {
    number: string;
    status: 'ERROR';
    error: number;
}

type HlrCheckResponse = HlrCheck | HlrCheckError;

declare class Hlr extends BaseModule {
    check(numbers: string | string[], idx?: string | string[]): Promise<HlrCheckResponse | HlrCheckResponse[]>;
}

interface MfaGenerateCodeOptions {
    content?: string;
    fast?: boolean;
    from?: string;
}

interface MfaResponse {
    id: string;
    code: string;
    phoneNumber: string;
    from: string | null;
}

declare class Mfa extends BaseModule {
    generateCode(number: string, options?: MfaGenerateCodeOptions): Promise<MfaResponse>;
    verifyCode(number: string, code: string): Promise<void>;
}

interface BaseMessageDetails {
    date?: Date;
    idx?: string;
    checkIdx?: boolean;
    notifyUrl?: string;
    test?: boolean;
}

type SmsEncoding = 'iso-8859-1' | 'iso-8859-2' | 'iso-8859-3' | 'iso-8859-4' | 'iso-8859-5' | 'iso-8859-7' | 'windows-1250' | 'windows-1251' | 'utf-8';
interface SmsDetails extends BaseMessageDetails {
    from?: string | '2way';
    encoding?: SmsEncoding;
    flash?: boolean;
    timeRestriction?: 'follow' | 'ignore' | 'nearest_available';
    udh?: string;
    skipForeign?: boolean;
    allowDuplicates?: boolean;
    checkIdx?: boolean;
    noUnicode?: boolean;
    normalize?: boolean;
    fast?: boolean;
    partnerId?: string;
    maxParts?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10;
    expirationDate?: Date;
    discountGroup?: string;
    param1?: string;
    param2?: string;
    param3?: string;
    param4?: string;
    template?: string;
    datacoding?: 'bin';
}

type MessageStatus = 'ACCEPTED' | 'DELIVERED' | 'EXPIRED' | 'FAILED' | 'NOT_FOUND' | 'QUEUE' | 'REJECTED' | 'RENEWAL' | 'SENT' | 'STOP' | 'UNDELIVERED' | 'UNKNOWN';

interface ApiMessageResponse {
    count: number;
    list: {
        id: string;
        points: number;
        number: string;
        dateSent: number;
        submittedNumber: string;
        status: MessageStatus;
        idx: string | null;
        parts?: number;
    }[];
    message?: string;
    length: number;
    parts?: number;
}
interface MessageResponse extends Omit<ApiMessageResponse, 'list'> {
    list: {
        id: string;
        points: number;
        number: string;
        dateSent: Date;
        submittedNumber: string;
        status: MessageStatus;
        idx: string | null;
        parts?: number;
    }[];
}

type VmsTtsLector = 'ewa' | 'jacek' | 'jan' | 'maja';

interface SmsContent {
    message: string;
}
interface MmsContent {
    smil: string;
    subject: string;
}
interface VmsTextContent {
    tts: string;
    ttsLector?: VmsTtsLector;
}
interface VmsLocalFileContent {
    localPath: string;
}
interface VmsRemoteFileContent {
    remotePath: string;
}
type MessageContent = MmsContent | SmsContent | VmsLocalFileContent | VmsRemoteFileContent | VmsTextContent;

interface NumberRecipient {
    to: string | string[];
}
interface GroupRecipient {
    group: string | string[];
}
type Recipient = NumberRecipient | GroupRecipient;
declare class BaseMessageModule extends BaseModule {
    protected endpoint: string;
    protected send(content: MessageContent, recipient: Recipient, details?: SmsDetails): Promise<MessageResponse>;
    private isNumberRecipient;
    private isGroupRecipient;
    private isSms;
    private isMms;
    private isVmsText;
    private isVmsLocalFile;
    private isVmsRemotePath;
    private getFormDataForVmsLocalFile;
    private formatSmsDetails;
    protected formatResponse(response: ApiMessageResponse): MessageResponse;
}

type MmsDetails = BaseMessageDetails;

declare class Mms extends BaseMessageModule {
    endpoint: string;
    sendMms(numbers: string | string[], subject: string, smil: string, details?: MmsDetails): Promise<MessageResponse>;
    sendMmsToGroup(groups: string | string[], subject: string, smil: string, details?: MmsDetails): Promise<MessageResponse>;
}

type PaymentType = 'prepaid' | 'postpaid' | 'subscription' | 'trial';

interface ProfileResponse {
    id: string;
    name: string;
    email: string;
    username: string;
    phoneNumber: string;
    paymentType: PaymentType;
    userType: 'native' | 'subuser';
    points?: number;
}

declare class Profile extends BaseModule {
    get(): Promise<ProfileResponse>;
}

interface SubuserCredentials {
    username: string;
    password: string;
    apiPassword?: string;
}

interface SubuserPoints {
    fromAccount: number;
    perMonth: number;
}

interface NewSubuser {
    credentials: SubuserCredentials;
    active?: boolean;
    description?: string;
    points?: SubuserPoints;
}

interface NewTemplate {
    name: string;
    template: string;
    normalize?: boolean;
}

interface ScheduledSmsResponse {
    count: number;
    list: {
        id: string;
    }[];
}

type SendernameStatus = 'ACTIVE' | 'INACTIVE' | 'DELETED' | 'PENDING' | 'REJECTED';

interface Sendername {
    createdAt: Date;
    isDefault: boolean;
    sender: string;
    status: SendernameStatus;
}

interface Subuser {
    id: string;
    username: string;
    active: boolean;
    description: string | null;
    points: SubuserPoints;
}

interface Template {
    id: string;
    name: string;
    template: string;
}

interface UpdateSubuser {
    credentials: Partial<Omit<SubuserCredentials, 'username'>>;
    active: boolean;
    description: string;
    points: Partial<SubuserPoints>;
}

interface MessageErrorResponse {
    error: number;
    message: string;
}

declare class Sendernames extends BaseModule {
    get(): Promise<ApiCollection<Sendername>>;
    getBySender(sender: string): Promise<Sendername>;
    create(sender: string): Promise<Sendername>;
    makeDefault(sender: string): Promise<void>;
    remove(sender: string): Promise<void>;
    private formatSendernameDates;
}

declare class Sms extends BaseMessageModule {
    endpoint: string;
    sendSms(numbers: string | string[], message: string, details?: SmsDetails): Promise<MessageResponse>;
    sendFlashSms(numbers: string | string[], message: string, details?: SmsDetails): Promise<MessageResponse>;
    sendSmsToGroup(groups: string | string[], message: string, details?: SmsDetails): Promise<MessageResponse>;
    sendFlashSmsToGroup(groups: string | string[], message: string, details?: SmsDetails): Promise<MessageResponse>;
    removeScheduledSms(smsId: string | string[]): Promise<ScheduledSmsResponse>;
}

declare class Subusers extends BaseModule {
    get(): Promise<ApiCollection<Subuser>>;
    getById(subuserId: string): Promise<Subuser>;
    create(newSubuser: NewSubuser): Promise<Subuser>;
    update(subuserId: string, updateSubuser: Partial<UpdateSubuser>): Promise<Subuser>;
    remove(subuserId: string): Promise<void>;
}

declare class Templates extends BaseModule {
    get(): Promise<ApiCollection<Template>>;
    getById(templateId: string): Promise<Template>;
    create(newTemplate: NewTemplate): Promise<Template>;
    update(templateId: string, newTemplate: Partial<NewTemplate>): Promise<Template>;
    remove(templateId: string): Promise<void>;
}

interface VmsDetails extends BaseMessageDetails {
    try?: 1 | 2 | 3 | 4 | 5 | 6;
    interval?: number;
    skipGsm?: boolean;
}

declare class Vms extends BaseMessageModule {
    endpoint: string;
    sendVms(numbers: string | string[], tts: string, ttsLector?: VmsTtsLector, details?: VmsDetails): Promise<MessageResponse>;
    sendVmsWithLocalFile(numbers: string | string[], pathToLocaleFile: string, details?: VmsDetails): Promise<MessageResponse>;
    sendVmsWithRemoteFile(numbers: string | string[], pathToRemoteFile: string, details?: VmsDetails): Promise<MessageResponse>;
    sendVmsToGroup(groups: string | string[], tts: string, ttsLector?: VmsTtsLector, details?: VmsDetails): Promise<MessageResponse>;
    sendVmsWithLocalFileToGroup(groups: string | string[], pathToLocaleFile: string, details?: VmsDetails): Promise<MessageResponse>;
    sendVmsWithRemoteFileToGroup(groups: string | string[], pathToRemoteFile: string, details?: VmsDetails): Promise<MessageResponse>;
}

declare class SMSAPI {
    private accessToken;
    private serviceUrl;
    private httpClient;
    contacts: Contacts;
    hlr: Hlr;
    mfa: Mfa;
    mms: Mms;
    profile: Profile;
    sendernames: Sendernames;
    sms: Sms;
    subusers: Subusers;
    templates: Templates;
    vms: Vms;
    constructor(accessToken: string, serviceUrl?: string);
    private getUserAgent;
    private getHttpClient;
}

export { type ApiCollection, type HlrCheck, type HlrCheckError, type HlrCheckResponse, type MessageErrorResponse, type MessageResponse, type MessageStatus, type MmsDetails, type NewSubuser, type NewTemplate, type PaymentType, type ProfileResponse, SMSAPI, type ScheduledSmsResponse, type Sendername, type SendernameStatus, type SmsDetails, type Subuser, type SubuserCredentials, type SubuserPoints, type Template, type UpdateSubuser };
